<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Melt rate parametrizations · WAVI.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="WAVI.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">WAVI.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation instructions</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../planar_1D_flow/">First example: one-dimensional planar flow</a></li><li><a class="tocitem" href="../mismip_plus/">MISMIP+ part one: grounding lines on overdeepened bed</a></li><li><a class="tocitem" href="../mismip_plus_retreat/">MISMIP+ part two: retreat experiments</a></li><li><a class="tocitem" href="../bumpy_bed/">Two-dimensional flow on a bumpy bed</a></li><li class="is-active"><a class="tocitem" href>Melt rate parametrizations</a><ul class="internal"><li><a class="tocitem" href="#Melt-rates-parametrizations"><span>Melt rates parametrizations</span></a></li><li><a class="tocitem" href="#Install-dependencies"><span>Install dependencies</span></a></li><li><a class="tocitem" href="#Model-Setup"><span>Model Setup</span></a></li><li><a class="tocitem" href="#Melt-Rate-Models"><span>Melt Rate Models</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Defining-A-New-Melt-Rate-Model"><span>Defining A New Melt Rate Model</span></a></li></ul></li><li><a class="tocitem" href="../stochastic_forcing/">Ice sheet retreat under stochastic forcing</a></li><li><a class="tocitem" href="../WAIS/">Real world: West Antarctic Ice Sheet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/overview/">Overview</a></li><li><a class="tocitem" href="../../physics/governing_equations/">Governing Equations</a></li><li><a class="tocitem" href="../../physics/melting/">Basal Melt Rate Parametrizations</a></li></ul></li><li><a class="tocitem" href="../../numerical_procedure/numerical_procedure/">Numerical Implementation</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../data_structure/overview/">Overview</a></li><li><a class="tocitem" href="../../data_structure/simulations/">Simulations</a></li><li><a class="tocitem" href="../../data_structure/model/">Models</a></li><li><a class="tocitem" href="../../data_structure/timestepping_params/">Timestepping Parameters</a></li><li><a class="tocitem" href="../../data_structure/output_writing/">Output Writing</a></li><li><a class="tocitem" href="../../data_structure/grid/">Grid</a></li><li><a class="tocitem" href="../../data_structure/solver_parameters/">Solver Parameters</a></li><li><a class="tocitem" href="../../data_structure/params/">Physical Parameters</a></li><li><a class="tocitem" href="../../data_structure/initial_conditions/">Initial Conditions</a></li><li><a class="tocitem" href="../../data_structure/fields/">Fields</a></li><li><a class="tocitem" href="../../data_structure/melt_rate_models/">Basal Melt Rate Models</a></li></ul></li><li><a class="tocitem" href="../../mitgcm_coupling/">MITgcm coupling</a></li><li><a class="tocitem" href="../../contributing/">Contributors guide</a></li><li><a class="tocitem" href="../../contact/">Contact us</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Melt rate parametrizations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Melt rate parametrizations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RJArthern/WAVI.jl/blob/main/docs/src/examples/melt_parametrizations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Melt-rates-parametrizations"><a class="docs-heading-anchor" href="#Melt-rates-parametrizations">Melt rates parametrizations</a><a id="Melt-rates-parametrizations-1"></a><a class="docs-heading-anchor-permalink" href="#Melt-rates-parametrizations" title="Permalink"></a></h2><p>This example demonstrates the how to use melt rate parametrizations in WAVI.jl. We first demonstrate the parametrizations included in WAVI.jl, by producing a map of the melt rate for each of these in the MISMIP+ steady state geometry. (MISMIP+ is the latest ice sheet model intercomparison exercise, for more info see doi:10.5194/tc-14-2283-2020) Explicitly, these parametrizations are:</p><ul><li>Quadratic melt rates</li><li>A plume melt emulator</li><li>PICO melt rate model</li><li>Binary file melt rate</li></ul><p>You can find more info on each of these models in the Physics –&gt; Melt Rates tab.</p><p>Secondly, we demonstrate how to add a simple melt rate model to WAVI.jl.</p><h2 id="Install-dependencies"><a class="docs-heading-anchor" href="#Install-dependencies">Install dependencies</a><a id="Install-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Install-dependencies" title="Permalink"></a></h2><p>First let&#39;s make sure we have all required packages installed. As well as WAVI and Plots for plotting, we&#39;re going to use the Downloads package to pull some data from a Github repository.</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(PackageSpec(url=&quot;https://github.com/RJArthern/WAVI.jl.git&quot;, rev = &quot;main&quot;))
Pkg.add(&quot;Plots&quot;), Pkg.add(&quot;Downloads&quot;)
using WAVI, Plots, Downloads</code></pre><h2 id="Model-Setup"><a class="docs-heading-anchor" href="#Model-Setup">Model Setup</a><a id="Model-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Setup" title="Permalink"></a></h2><p>First we&#39;ll make the grid. The MISMIP+ grid has length 640km and 80km in the x and y directions, respectively. We&#39;re going to choose 2km resolution in both directions, i.e. 320 grid points in the x-direction and 40 grid points in the y-direction.</p><pre><code class="language-julia hljs">nx = 320;
ny = 40;
grid = Grid(nx=nx,ny=ny,dx=2000.,dy=2000.);</code></pre><p>For the bed, we&#39;ll cheat a little and use the &quot;hard coded&quot; form of the MISMIP+ bed (see the &quot;MISMIP+&quot; example to see how to define this bed properly)</p><pre><code class="language-julia hljs">bed = WAVI.mismip_plus_bed # function definition</code></pre><p>To allow us to focus on the melt rate parametrizations, we&#39;re not going to run a simulation to define the steady state ice thickness, but rather pull it from Github, where it is stored as a binary file. (Note that this ice thickness is the result of the &quot;MISMIP+&quot; example, but with 2km resolution.)</p><pre><code class="language-julia hljs">fname = Downloads.download(&quot;https://github.com/alextbradley/WAVI_example_data/raw/main/MISMIP_PLUS/WAVI_ice0_2km_thick.bin&quot;);
h = Array{Float64,2}(undef, nx, ny);
read!(fname, h);
h = ntoh.(h);
# (The final line simply converts the endianness from big-endian --  the format in which this file is stored -- to little-endian.)</code></pre><p>Now we make an InitialConditions object to store this ice thickness</p><pre><code class="language-julia hljs">global initial_conditions = InitialConditions(initial_thickness = h);</code></pre><p>(We make this a global variable because we&#39;ll use it in a loop later.)</p><h2 id="Melt-Rate-Models"><a class="docs-heading-anchor" href="#Melt-Rate-Models">Melt Rate Models</a><a id="Melt-Rate-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Melt-Rate-Models" title="Permalink"></a></h2><p>We&#39;ll loop over each of the melt rate models mentioned above. For each, we&#39;ll produce a map of the melt rate in the MISMIP+ geometry that we just downloaded.</p><p>First let&#39;s make the melt rate models in turn, starting with quadratic, which is imposed on the model via a <code>QuadraticMeltRate</code> object</p><pre><code class="language-julia hljs">melt_quad = QuadraticMeltRate(γT = 0.745*1e-3)</code></pre><p>The parameter <span>$\gamma_T$</span> is a normalization cofficient. The value here is chosen so that the mean melt rate on the shelf is approx 10m/a. (See the &quot;WAVI Setup&quot; –&gt;  &quot;Melt Rate Models&quot; section for information on all keyword parameters, here and for the below models.)</p><p>Next up: PICO. For this parametrization, we first have to make a mask defining where the ice front is, and then pass it as a keyword argument when we instantiate the <code>PICO</code> melt rate object.</p><pre><code class="language-julia hljs">ice_front_mask = zeros(nx,ny);
ice_front_mask[end,:] .= 1; #this tells julia that the ice front is at the downstream end of the domain
melt_PICO = PICO(ice_front_mask = ice_front_mask, 
                    T0 = 1.2, 
                    S0 = 34.6, 
                    γT = 0.87e-5, 
                    nbox = 5);</code></pre><p>Again, <span>$\gamma_T$</span> is a normalization coefficient.</p><p>Next up: plume model emulator:</p><pre><code class="language-julia hljs">melt_PME = PlumeEmulator(α=1.49);</code></pre><p>In this case, the normalization coefficent is named <span>$\alpha$</span>, and has a slightly different meaning to <span>$\gamma_T$</span> above, but we use it in the same role: to the set the mean melt rate on the shelf.</p><p>Finally, a binary file melt rate, in which the melt rate is read in from a binary file. First, we&#39;ll create such a file, which will set the melt rate to be uniform on the shelf.</p><pre><code class="language-julia hljs">isfloat = (h .&lt; -918.0/1028.0 .* bed.(grid.xxh, grid.yyh)) #indices of floating elements
m = zeros(nx,ny);
m[isfloat] .= 10.0; #set everywhere floating to 10m/a
folder = joinpath(@__DIR__, &quot;melt_rate_parametrizations&quot;);
isdir(folder) &amp;&amp; rm(folder, force = true, recursive = true);
mkdir(folder) ;
out = open(joinpath(folder,&quot;melt.bin&quot;), &quot;w&quot;);
write(out, m);
close(out);</code></pre><p>Now we instantiate out melt rate opject, pointing it to this file we just created:</p><pre><code class="language-julia hljs">binfile_melt = BinfileMeltRate(input_filename = joinpath(folder,&quot;melt.bin&quot;))</code></pre><p>It&#39;s useful to put these into a dictionary, so we can iterate over them. Again, we use a global variable to facilitate this</p><pre><code class="language-julia hljs">global melt_rates = Dict(&quot;Quadratic&quot; =&gt; melt_quad, &quot;PME&quot; =&gt; melt_PME, &quot;PICO&quot; =&gt; melt_PICO, &quot;Binary file&quot; =&gt; binfile_melt)</code></pre><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>We&#39;ll loop over the melt rate models instantiated above. Each time, we make a WAVI.jl <code>Model</code> with the appropriate melt rate parametrization specified via the <code>melt_rate</code> keyword.  We use the <code>update_state!</code> method to bring the melt (as well as all other quantities, such as the grounded fraction) in line with the specified thickness, and then plot the melt rate. (We also set the number of Picard iterations to 1 – each time we do an <code>update_state!</code> we perform a velocity solve; in this example, we don&#39;t care about the velocity solve being completely accurate, so we&#39;ll do the minimum number of iterations in this process!)</p><pre><code class="language-julia hljs">for (key, melt) in melt_rates
    #instantiate the model with the appropriate melt rate
    local model = Model(grid = grid,
            bed_elevation = bed, 
            initial_conditions = initial_conditions,
            solver_params = SolverParams(maxiter_picard=1),
            melt_rate = melt);

    #bring quantities in line with the thickness
    update_state!(model);

    #extract the melt rate, remove any grounded entries and saturate the melt rate to 50 m/a
    mcopy= deepcopy(model.fields.gh.basal_melt)
    mcopy[model.fields.gh.grounded_fraction .== 1.] .= NaN
    msat = deepcopy(mcopy)
    msat[msat .&gt; 50] .= 50

    #plot the melt rate
    plt = Plots.heatmap(model.grid.xxh[:,1]/1e3, model.grid.yyh[1,:]/1e3, msat&#39;, 
                        xlabel = &quot;x (km)&quot;, 
                        ylabel = &quot;y (km)&quot;,
                        colorbar_title = &quot;melt rate (m/yr)&quot;,
                        title = key,
                        framestyle = &quot;box&quot;)
    xlims!((420, 640))
    plot!(size = (500,300))

    # save the figure
    savefig
    display(plt) #uncomment to show in (e.g.) VSCode
end</code></pre><center><img src="https://raw.githubusercontent.com/RJArthern/WAVI.jl/build-docs/docs/src/assets/example-plots//melt_parametrizations//quadratic.png" alt="" title="" width="600" height="600" /></center><center><img src="https://raw.githubusercontent.com/RJArthern/WAVI.jl/build-docs/docs/src/assets/example-plots//melt_parametrizations//pico.png" alt="" title="" width="600" height="600" /></center><center><img src="https://raw.githubusercontent.com/RJArthern/WAVI.jl/build-docs/docs/src/assets/example-plots//melt_parametrizations//plume.png" alt="" title="" width="600" height="600" /></center><center><img src="https://raw.githubusercontent.com/RJArthern/WAVI.jl/build-docs/docs/src/assets/example-plots//melt_parametrizations//binary.png" alt="" title="" width="600" height="600" /></center><p>As a sanity check, the binary file melt rate has the same (10m/a)melt rate over the whole shelf. The PICO parametrization, which divides the shelf up into discrete chunks, has a corresponding banded structure, with highest melt rates at the grounding line (note the different colourbar limits on the various plots!). The quadratic melt rate parametrizations similarly has the highest melt rate near the grounding line, but drops off with distance from the grounding line much quicker than the PICO parametrization. These plots can be compared to corresponding results for the NEMO ocean model  (Favier et al. 2019 doi:10.5194/gmd-12-2255-2019)</p><h2 id="Defining-A-New-Melt-Rate-Model"><a class="docs-heading-anchor" href="#Defining-A-New-Melt-Rate-Model">Defining A New Melt Rate Model</a><a id="Defining-A-New-Melt-Rate-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-A-New-Melt-Rate-Model" title="Permalink"></a></h2><p>In this section, we show how to specify a new melt rate model. NB: This is experimental and still in development. It is also a bit tricky and requires knowledge of constructors and julia&#39;s type system. We&#39;re more than happy to help: please get in touch!</p><p>There are four steps to creating a new melt rate model:</p><ul><li>Create a file to store code</li><li>Define the appropriate structure, which stores information required to prescribe the melt rate</li><li>Define a constructor of this structure</li><li>Write a function to update the melt rate appropriately, and export this</li></ul><p>This is quite abstract, so let&#39;s do an example. We&#39;ll create a melt rate model which sets the melt rate as it is specified in the MISMIP+ experiment, where the melt rate on floating cells is <span>$0.2 \tanh((z_d - z_b)/75) \max(-100 - z_d,0)$</span>, where <span>$z_d$</span> is the ice shelf draft and <span>$z_d - z_b$</span> is the cavity thickness.  We&#39;ll follow the steps above: first, we create a file to store the code. For this example, we&#39;ve already create the file, you can see it at it at &quot;./src/MeltRate/mismip<em>melt</em>rate.jl&quot;.</p><p>Next we define a structure, which stores parameters related to the melt rate model. Note that the melt rate model does not &quot;own&quot; the melt rate, the <code>model</code> does (and stores it in model.fields.gh.basal_melt, see below)</p><pre><code class="language-julia hljs">struct MISMIPMeltRateOne{T &lt;: Real} &lt;: AbstractMeltRate 
    α  :: T
    ρi :: T
    ρw :: T
end</code></pre><p>In this case, the parameters are: a normalization coefficient <span>$\alpha$</span>, and the denisities of ice and ocean, <span>$\rho_i$</span> and <span>$\rho_w$</span>, respectively. </p><p>Now we define our &quot;constructor&quot;, a function that defines how to create one of these structures:</p><pre><code class="language-julia hljs">MISMIPMeltRateOne(; α = 1.0, ρi = 918.0, ρw = 1028.0) = MISMIPMeltRateOne(α,ρi, ρw)</code></pre><p>In this case, the constructor simply sets the default values for the parameters <span>$\alpha$</span>, <span>$\rho_i$</span>, and <span>$\rho_w$</span>. NB: for more complicated melt rate models, constructors might be more elaborate! You can see constructors for the various models considered above by diving into the &quot;./src/MeltRate&quot; folder.</p><p>The final step is to define a function <code>update_melt_rate!(melt_rate::TYPE, fields, grid)</code> which tells WAVI how to update the melt rate in this example. Here, TYPE is the name of the structure we just made (e.g. <code>update_melt_rate!(melt_rate::MISMIPMeltRateOne, fields, grid)</code>).</p><p>Note that the arguments of this function must be as mentioned here, so that the multiple dispatch capability of julia can be leveraged!  Effectively, what we&#39;re doing is defining another method (think: function) named <code>update_melt_rate!</code>, which sets the melt rate according to this function when the input melt rate is of type &quot;TYPE&quot;. Each of the melt rate models listed above has one of these functions. </p><pre><code class="language-julia hljs">function update_melt_rate!(melt_rate::MISMIPMeltRateOne, fields, grid) 
    draft = -(melt_rate.ρi / melt_rate.ρw) .* fields.gh.h
    cavity_thickness = draft .- fields.gh.b
    cavity_thickness = max.(cavity_thickness, 0)
    m =  melt_rate.α .* 0.2*tanh.(cavity_thickness./75).*max.((-100 .- draft), 0)
    fields.gh.basal_melt[:] .= m[:]
end</code></pre><p>Finally, we tell point WAVI to this code by adding <code>include(&quot;mismip_melt_rate.jl&quot;)</code> to the file &quot;src/MeltRate/MeltRate.jl&quot;, and add this structure to the export section in &quot;src/WAVI.jl&quot; file. (We already did this for this MISMIP melt rate!)</p><p>Now we can create a model which takes this melt rate and plot the result:</p><pre><code class="language-julia hljs">model = Model(grid = grid,
            bed_elevation = bed, 
            initial_conditions = initial_conditions,
            solver_params = SolverParams(maxiter_picard=1),
            melt_rate = MISMIPMeltRateOne());

update_state!(model);
m = deepcopy(model.fields.gh.basal_melt)
m[model.fields.gh.grounded_fraction .== 1.] .= NaN
msat = deepcopy(m)
msat[msat .&gt; 50] .= 50

plt = Plots.heatmap(model.grid.xxh[:,1]/1e3, model.grid.yyh[1,:]/1e3, msat&#39;, 
            xlabel = &quot;x (km)&quot;, 
            ylabel = &quot;y (km)&quot;,
            colorbar_title = &quot;melt rate (m/yr)&quot;,
            title = &quot;MISMIP melt rate&quot;,
            framestyle = &quot;box&quot;)
xlims!((420, 640))
plot!(size = (500,300))
#display(plt)</code></pre><center><img src="https://raw.githubusercontent.com/RJArthern/WAVI.jl/build-docs/docs/src/assets/example-plots//melt_parametrizations//mismip.png" alt="" title="" width="600" height="600" /></center><p>Hopefully this example demonstrates the procedure for adding melt rate models to WAVI.jl. If there are any questions, don&#39;t hesistate to get in touch (see the &quot;Contact Us&quot; tab)</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bumpy_bed/">« Two-dimensional flow on a bumpy bed</a><a class="docs-footer-nextpage" href="../stochastic_forcing/">Ice sheet retreat under stochastic forcing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 13 March 2024 20:19">Wednesday 13 March 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
